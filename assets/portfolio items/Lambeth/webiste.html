<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Report of unemployment in Lambeth</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="webiste_files/libs/clipboard/clipboard.min.js"></script>
<script src="webiste_files/libs/quarto-html/quarto.js"></script>
<script src="webiste_files/libs/quarto-html/popper.min.js"></script>
<script src="webiste_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="webiste_files/libs/quarto-html/anchor.min.js"></script>
<link href="webiste_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="webiste_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="webiste_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="webiste_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="webiste_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>



<body class="fullcontent">
  <div style="margin-top: 20px;">
    <a href="../../../portfolio.html" class="back-button">← Back to Portfolio</a>
  </div>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">



<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Report of unemployment in Lambeth</h1>
</div>


<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="executive-summary" class="level2">
<h2 class="anchored" data-anchor-id="executive-summary">Executive Summary:</h2>
<p>This report looks at the geography of unemployment within Lambeth, there are significant clusters of high unemployment in the North East region which also seem to be where there is a higher concentration of social housing. Upon investigating further, there is a positive relationship between the presence of social housing and unemployment in this region. Policy makers should target this area and implement strategies such as mixed-income development to reduce unemployment.</p>
<p>The report uses variables from the 2021 UK census data (see appendix) and is at output area (OA) level.</p>
<hr>
<div class="cell" data-layout-align="center">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="webiste_files/figure-html/unnamed-chunk-2-1.png" class="img-fluid figure-img" width="672"></p>
<figcaption>Distribution of Unemployment in Lambeth</figcaption>
</figure>
</div>
</div>
</div>
<p>The map above presents an overview of the geography of unemployment within the borough, with darker shades indicating higher levels of unemployment. At first glance, it seems like the majority of the borough sees 2.60% to 6.07% of unemployment, however we can small pockets of high unemployment in the North East and South East region as well as low unemployment in the Western region. To investigate this further, LISA maps were created as shown below.</p>
<div class="cell" data-layout-align="center">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="webiste_files/figure-html/unnamed-chunk-4-1.png" class="img-fluid figure-img" width="672"></p>
<figcaption>LISA map showing spatial autocorrelation</figcaption>
</figure>
</div>
</div>
</div>
<p>The map reveals patterns of spatial autocorrelation in the North East, South East, and Western regions, where clusters of both positive and negative spatial autocorrelation are present. Positive clusters, indicated as HIGH-HIGH, represent areas with high unemployment surrounded by similarly high levels, while LOW-LOW clusters signify areas with low unemployment surrounded by similarly low levels. Negative clusters, such as LOW-HIGH, are areas of low unemployment close to high unemployment areas, and HIGH-LOW clusters are areas of high unemployment surrounded by low unemployment areas.&nbsp;</p>
<p>These clusters are not randomly dispersed but form identifiable patterns, with the North East showing moderately sized red clusters of high unemployment interspersed with light blue clusters, suggesting that although there are some areas with high levels of unemployment, there are areas closeby that see a very mixed level of unemployment. A similar pattern emerges in the West, where dark blue clusters of low unemployment are interspersed with areas of mixed employment levels showing abrupt transitions between high and low unemployment.</p>
<p>To gain more insight into these clusters and disparities, we will use another variable, social housing.</p>
<div class="cell" data-layout-align="center">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="webiste_files/figure-html/unnamed-chunk-6-1.png" class="img-fluid figure-img" width="672"></p>
<figcaption>Maps of distribution of social housing (left) and GWR coefficients (Right)</figcaption>
</figure>
</div>
</div>
</div>
<p>The left map shows the distribution of social housing in Lambeth; when looking at it with the LISA map, we can see that the red areas (high unemployment close to similar levels) have higher levels of social housing in those clusters. The same goes for the regions in the south of Lambeth. In the Western region, we can see that the dark blue areas (low unemployment close to similar levels) see less social housing. However there are still noticeable pockets of high social housing in the region which may be one of the causes for the negative spatial autocorrelation of unemployment, and vice versa for the North Eastern and Southern regions.</p>
<p>The right map shows the impact of social housing on unemployment in different areas, the darker orange areas have a stronger positive relationship, meaning that the impact of social housing on higher unemployment rates is strongest here. Noticeably, the darkest areas (0.054 to 0.061) are the areas with high levels of unemployment and social housing, therefore policy makers should focus on the areas that identify with the red HIGH-HIGH clusters, particularly those in the North East and less so in the South East. One reason why those in the South East may not see as much correlation despite having similar amounts of social housing and unemployment is because it is close to the border of Croydon, which may see vastly different characteristics to those in Lambeth, therefore other factors may play a larger role in shaping unemployment there.</p>
<p>Below is a map that shows the R-squared values for the GWR model; it seems like regions above the center have higher predictive capabilities than those below it, with the highest being in the West with 40% to 50%. The areas that are of concern (parts of North East) see a predictive capability of 25% to 40%. The fact that the highest R-squared value is around 50% suggests that there are other variables that are impacting unemployment aside from social housing which warrants further investigation, particularly in the South East where the model is not as strong.</p>
<div class="cell" data-layout-align="center">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="webiste_files/figure-html/unnamed-chunk-7-1.png" class="img-fluid figure-img" width="672"></p>
<figcaption>Map of local R-squared values</figcaption>
</figure>
</div>
</div>
</div>
<p>Ultimately, the analysis highlights a positive relationship between unemployment and social housing. Policymakers should prioritise interventions in the North East red areas in Figure 2, where the concentration of social housing and its correlation with unemployment are most pronounced. A key strategy could involve promoting mixed-income developments in these regions, making housing accessible to individuals across various income levels and therefore integrating people of various social backgrounds.</p>
<p>This approach could help reduce unemployment by creating stronger social networks, where residents from diverse economic backgrounds can interact, share resources, and create opportunities for employment. By integrating social housing into mixed-income communities, the negative effects of economic clustering can be mitigated, enabling better access to social capital and job-related connections (Tunstall, 2010).&nbsp; The theoretical reasoning to this is due to increased social capital for the unemployed residents, informal social control and the higher income residents acting as role models via social learning (Joseph, 2016), resulting in opportunities to get employment.</p>
<p>In conclusion, breaking up high-density clusters of social housing with mixed-income developments has the potential to alleviate unemployment in these areas, promoting more inclusive and economically resilient neighbourhoods.</p>
<hr>
</section>
<section id="technical-appendix" class="level2">
<h2 class="anchored" data-anchor-id="technical-appendix">Technical Appendix</h2>
<ol type="1">
<li><strong>Rationale for chosen methodologies</strong></li>
</ol>
<section id="classification-method" class="level4">
<h4 class="anchored" data-anchor-id="classification-method">Classification method:</h4>
<p>Jenks was chosen to classify data because it finds natural breaks in the data, the breaks are based on natural groupings inherent in the data and aims to group similar values together whilst maximising the differences (Chen, 2013). Therefore Jenks aims to reduce variance within classes and maximise variance between classes (Esri, 2010)</p>
</section>
<section id="morans-i" class="level4">
<h4 class="anchored" data-anchor-id="morans-i">Moran’s I:</h4>
<p><strong>Row standardisation weighting:</strong></p>
<p>For the style of row standardisation, “W” was chosen as it gives more weight to spatial objects with fewer neighbours. This ensures that areas at the edges of Lambeth with fewer neighbours are given more weight, for example there are quite a few parks that border Lambeth (Clapham Common, Tooting Commons etc.) as well as the River Thames in the North West. Using “W” ensures that the areas here are given higher weights so that the clusters here are not overlooked.</p>
<p><br>
<strong>Neighbour distance threshold:</strong></p>
<p>When using Rooks or Queen’s methods to find neighbours, neither reached a satisfactory amount of average links. Both methods produced an average number of 5 links whereas the ideal number is 8. Furthermore, the values for the local Moran’s I fell outside of -1 and 1. Therefore a distance based approach was taken where 1400m (1.4km) was deemed to be ideal, with 177 average links. The Moran’s I statistics for this distance were between -0.67 and 1.29, which had the smallest deviation from -1 to 1 from the other distances that had been tested.</p>
<p><strong>Moran’s I statistic:</strong></p>
<p>The global Moran’s I statistic is 0.035, with a significant p-value (&lt; 2.2e-16), therefore we can assume that the unemployment variable is positively autocorrelated in Lambeth and can reject the NULL hypothesis of spatial randomness, meaning that the data spatially clusters. Therefore, a local Moran’s test was conducted after this to determine the degree of spatial autocorrelation in areas of Lambeth. Afterwards, a LISA map was made to determine which areas had positive autocorrelation or negative autocorrelation.</p>
</section>
<section id="gwr" class="level4">
<h4 class="anchored" data-anchor-id="gwr"><strong>GWR:</strong></h4>
<p>First, a linear regression model was run, with an R-squared value of 0.29, suggesting that 29% of the variation of unemployment could be explained by this model. Since the overall fit of the model may vary across space, mapping the residuals will allow us to see how well the model fits different areas. The model states that the residuals ranged from -5.5 to 12.5, with a median of -0.2. As shown in the map below, much of the residuals were between -5 to 5.</p>
<div class="cell" data-layout-align="center">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="webiste_files/figure-html/unnamed-chunk-8-1.png" class="img-fluid figure-img" width="672"></p>
<figcaption>Map showing distribution of residual values</figcaption>
</figure>
</div>
</div>
</div>
<p>To gain further insights into whether the relationship between unemployment and social housing varies in space, GWR was conducted.</p>
<p>An adaptive bandwidth was selected due to the differing sizes and density of the OA’S. An adaptive bandwidth identifies spatial extents of density variation and produces values that are more comparable between locations (Xun, 2010). Therefore it helps to capture spatial patterns more accurately based on the local context as opposed to a fixed bandwidth.</p>
<ol start="2" type="1">
<li><p><strong>Description of dataset</strong></p>
<table class="caption-top table">
<colgroup>
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 25%">
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>Column Code</th>
<th>Description</th>
<th>Source</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Economic activity status</td>
<td>OA</td>
<td>Output Area</td>
<td>All_2021_Census: ts066.csv</td>
</tr>
<tr class="even">
<td>Economic activity status</td>
<td>ts0660001</td>
<td>Economic activity status: Total: All usual residents aged 16 years and over</td>
<td></td>
</tr>
<tr class="odd">
<td>Economic activity status</td>
<td>ts0660013</td>
<td>Economic activity status: Economically active (excluding full-time students): Unemployed</td>
<td></td>
</tr>
<tr class="even">
<td>Tenure of Household</td>
<td>OA</td>
<td>Output Area</td>
<td>All_2021_Census: ts054.csv</td>
</tr>
<tr class="odd">
<td>Tenure of Household</td>
<td>ts0540001</td>
<td>Tenure of household: Total: All households</td>
<td></td>
</tr>
<tr class="even">
<td>Tenure of Household</td>
<td>ts0540007</td>
<td>Tenure of household: Social rented</td>
<td></td>
</tr>
<tr class="odd">
<td>Unemployed</td>
<td></td>
<td>Percentage of people unemployed within each OA</td>
<td>(ts0660013/ts0660001)*100</td>
</tr>
<tr class="even">
<td>Social</td>
<td></td>
<td>Percentage of people in social housing within each OA</td>
<td>(ts0540007/ts0540001)*100</td>
</tr>
</tbody>
</table></li>
</ol>
<hr>
</section>
<section id="bibliography" class="level3">
<h3 class="anchored" data-anchor-id="bibliography">Bibliography</h3>
<p>Chen, J., Yang, S. T., Li, H. W., Zhang, B., &amp; Lv, J. R. (2013). Research on geographical environment unit division based on the method of natural breaks (Jenks). The International Archives of the Photogrammetry, Remote Sensing and Spatial Information Sciences, 40, 47-50.</p>
<p>Esri. (n.d.). Jenks’ optimization. In GIS Dictionary. Retrieved January 9, 2025, from<a href="https://support.esri.com/en-us/gis-dictionary/jenks-optimization" class="uri">https://support.esri.com/en-us/gis-dictionary/jenks-optimization</a></p>
<p>Joseph, M. L., &amp; Yoon, M. (2016). Mixed-income developments. The Wiley Blackwell encyclopedia of urban and regional studies.</p>
<p>Tunstall, R., &amp; Lupton, R. (2010). Mixed communities evidence review. Department for Communities and Local Government.</p>
<p>Xun Shi (2010) Selection of bandwidth type and adjustment side in kernel density estimation over inhomogeneous backgrounds, International Journal of Geographical Information Science, 24:5, 643-660</p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>